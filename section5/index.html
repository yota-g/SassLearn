ミックスインと継承
25.ミックスインの基本
強力な機能
スタイルの集まりをミックスインで定義するといろいろな場所から呼び出す事ができる。
定義して、色んな場所から呼び出せるものは変数と同じだが、変数は数値や文字列を定義するものだったが、ミックスインで定義できるのはスタイルの集まり。
ミックスインに引数という形で外から値を渡す事で、定義したスタイルの形を一部変更して使用することもできる。

定義の仕方。@mixin　名前 {スタイルを定義}
@mixin roundBox {
  border-radius: 10px;
  background: #ededed;
  border: 1px solid #666;
}
書いてもcss には何も書き出されず、使用するにはincludeを使用する。
まずはセレクターを指定する。
.sideArea {
  include roundBox; 
}
と書くことで.sideAreaの中に指定したミックスインが入り、cssが出力される。

mixinは何度でも繰り返して使用する事ができる。
定義するときの@mixinと@includeは常にセットで使用するので覚える事。

変数と同じようにミックスインの命名にもルールがある。
ルールは変数と同じ。英数字-_とマルチバイト文字も使用することできる。
@mixin _box{}
@mixin -box{}
@mixin 文字列
はつけられるが、変数と同じで半角数字から始まるものはつけられない。
半角数字から始めるとエラーコードが出る。
invalid name in @mixin definitioと表示される。
そして、ビルドが止まる。

mixinのスコープも変数と同じ。
セレクタの中でmixinを定義する事ができる。
セレクタの中で定義したものは同じセレクタの中でしか使用できない。
セレクタ外で読み込もうとするとエラーが出る。
no mixin named mainBoxと表示されて出力されない。　
元々様々なところで使用することを想定したものなのでわざわざスコープを限定したものにする必要はないがスコープがあることを覚えておく。


26.ミックスインへの引数の指定。lecutre26.scss参照
mixinには外から引数を渡す事ができる。
引数とは関数の処理などで外から渡す値のことをいう。
引数の値を使って、プログラムの処理を行う。

引数を受け取る事ができるミックスインを定義するには、ミックスイン名の後に（）を記入して指定する。 $引数名
$valueはミックスインの中では、変数と同じように使用する事ができる。
@mixin paddingBox ($value) {
  padding: $value;
}

引数を指定して呼び出す時は、includeのmixin名の後に（）を書いて呼び出す。
#main {
  .mainBox{
    @include paddingBox(10px);
  }
}
そうするとpaddingが10pxのmainBoxが出力される。
mixinの中で引数は変数として扱う事ができるので、
ミックスインの中で演算することもできる。

mixinを渡す時通常は決まった値を渡したいが、決まった時に決まった値を渡した時
どうするのか。
mixinを呼び出すたびに記入するのは面倒。
引数にデフォルトの初期値を設定しておくと、引数なしで行うとその初期値を使用してミックスインさせる事ができる。

初期値の設定は　引数名: 初期値で設定できる
設定すると引数なしで呼び出すと初期値が適用されて出力される。
引数を入れない時は（）がなくても大丈夫。

27.複数の引数の指定するミックスイン
複数の引数の指定ができる。
引数ごとに,（カンマ）で区切る。

@mixin font ($color, $size) {
  color: $color;
  font-size: $size;
} のように指定できる。

引数が複数あっても初期値を指定する事ができる。
使用方法は同じ。
全ての引数を省略する時は何も書かなくていいが、
いずれかを入力したい場合、その他を省略できるのか。
途中の引数の省略はできない。
$colorを省略して、$sizeを書くことはできない。
  .second { @include font(, 20px);}はできない。エラーになる。
  この場合どうするのか。
  変数名を指定して、:で区切るとできる。@include font ($size: 20);
とする事でエラーがなくなる。

$colorを指定して、$sizeを省略する事はできる。(#00f)

引数は、多すぎてもやりづらいので4〜5ぐらいまでにした方がいい。

28.可変長引数
個数を限定しないで複数の引数を与える事ができるもの。
text-shadowやbox-shadowなど複数の引数を設定できるものなどを引数でカンマ区切りの値を渡すにはどうしたらいいのか。
引数を2つ設定する場合。 それぞれカンマ区切りで指定する。
@mixin shadow ($value){
  text-shadow: $value;
}
.main {
@include shadow(8px 8px 0 #666 , 10px -10px 0 #999)
}

これを保存すると、エラーが出る。
なぜか、shadowというmixインには1つしか引数が指定されていないのに、
呼び出す方で、カンマ区切りで指定しているので2つの引数を指定しているということになっているから。

これを解決する方法は3つある。
1, （）でいれる引数を括ってあげる。
@include shadow ((8px 8px 0 #666 , 10px -10px 0 #999))
そうするとちゃんと表示される。

2,文字列として渡す。
（）の中を文字列で渡す事で1つものもとして扱われるのでエラーにならない。
@include shadow("8px 8px 0 #666 , 10px -10px 0 #999");
ただし、出力される方にもダブルクォーテーションが入ってしまうので、
cssとしてはエラーになる。
ダブルクォーテーションを外すためにunquoteという関数を使用して渡す事でダブルクォーテーションが外されて表示される。
@include shadow (unquote ("8px 8px 0 #666 , 10px -10px 0 #999"));

3,可変長引数を使用する。
可変長引数を使用するには、mixinの引数の後ろに...を記入する事で可変長引数となり、個数を限定せず引数をとる事ができる。

@mixin shasdow ($value...){
  text-shadow: $value ;
}
とする事で
呼び出す方も特にカッコや文字列にせず呼び出せる。

可変長引数のもう一つの使用方法。
複数の引数を指定するmixinに対して、可変長引数で引数の値を渡すということをする。
@mixin box ($w: 300px, $pd: 20px, $mg: 40px, $clr: #f00) {
  width: $w;
  padding: $pd;
  margin: $mg;
  color: $clr;
}

$value: 200px, 40px,  //変数として、カンマ区切りの値をvalueで設定する。
boxというmixinにvalue という変数を引数として渡して,mixinを使用する。


.main {
  @include box($value);
}
のように引数を使用すると、widthの部分に200px, 40px;のように入ってしまうので
そこで可変長引数を使用する。
@include box ($value2...);と設定すると、
width: 200px;
padding: 40px;という風に2つに分けられて出力されるようにできる。

29.ミックスインにコンテントブロックを渡す。
ミックスインには引数を渡すだけではなく、コンテントブロックとしてスタイルの集まりを渡す事ができる。
コンテントブロックを渡すのでわかりやすいのはメディアクエリ。
メディアクエリの中に外から渡されたコンテントを展開させたい場所に@contentと書くと外から渡されたコンテントを展開させる事ができる。

コンテントブロックを渡せるミックスインの使用方法は、
セレクタとスタイルを定義する必要がある。
mixinを使用したい場所に@include media {}を記載。
{}の中にコンテントブロックとして渡したいスタイルを記載する。
そうすると、ミックスインで定義したメディアクエリの中に.item.image{float: none}が展開されているというようになっている。
@mixin media {
  @media only screen and (max-width: 768px) {
    @content;
  }
}

.item {
  .image {
    float: left;
    @include media {
      float: none; 
    }
  }
}

また、ミックスインなので繰り返し使用する事ができるので、
ミックスインを定義しておく事で繰り返し、メディアクエリを複数箇所で使用していたとしても、１箇所ミックスインの部分を変えると全てメディアクエリの条件が変更されるのでとても便利。(max-widthの値を変更など、、)

また、コンテントブロックを渡すミックスインも引数を指定することもできる。
外で定義した変数をmixinに渡すこともでき、そうすることで柔軟なmixinが作る事ができる。

30.継承の基本 lecture33.scss
継承する先のものを指定する。
継承したい対象の中で、@area .継承したいクラス
.area {
  @extent .box;
  background: #ededed;
}
継承元と同じものは継承元とグループ化され、それ以外は差分だけが継承されたセレクタの部分で表示される。
ミックスイント違って、継承の元となるものも書き出される。

extend専用のものにしたかったり、cssに書き出す必要がない場合に書き出さないようにすることもできる。
exted専用のフォルダーにするプレスフォルダーセットにする方法がある。
.や#の代わりに％に置き換えるとプレスフォルダにしたboxは消えてareaだけのcssの表示になる。
継承先のセレクターだけがスタイルに適用され表示されている。

継承ができるセレクターの種類について、
idセレクター、classセレクター、typeセレクター、連結セレクター、
属性セレクター、擬似クラス、擬似要素が継承元としてextendの後ろに書く事ができる。
.box {
  padding: 10px;
  クラスセレクタ
}

p {
  font-size: 12px;
  タイプセレクタ
}

#box {
  margin-bottom: 30px;
  idセレクタ
}

.box .red {
  color: #f00;
  連結セレクタ
}

input [type="text"] {
  border: 1px solid #666;
  属性セレクタ
}

a:hover {
  text-decoration: underline;
  擬似クラス
}

li:fiirst-child {
  margin-top: 10px;
  擬似要素
}


継承元にできないセレクターは、子孫セレクタ、子セレクタ、隣接セレクタ、間接セレクタがある
親子関係など複数のセレクタとなっているものは継承元として使用できない。


#main section {　他のセレクタとの組み合わせで子孫セレクタは構成される
  padding: 10px;
  子孫セレクタ
}

#main > article {
  margin-bottom: 20px;
  子セレクタ
}

h2 > h3 {
  font-size: 15px;
  隣接セレクタ
}

h2 ~ h3 {
  color: #999;
  間接セレクタ
}

メディアクエリの中での継承の注意点
メディアクエリの外のセレクタをメディアクエリの中から継承することはできない。
外のセレクタを継承するとビルド時にエラーになる。
%box {
  padding: 20px;
  border: 1px solid #ccc;
}


@media only screen and (max-width: 768px;){
  .item {
    @extend %box;
  }
}
メディアの外のextendはできないというエラーが表示される。
メディアクエリの中でセレクタをextendしたい場合は、メディアクエリの中で設定する。　
メディアクエリの中同士であれば、継承されたセレクタが出力される。

また、メディアクエリの中で設定されたセレクタをメディアクエリの外でextendしてもエラーにはならないが、期待した動作にはならない。
メディアクエリの外側には表示されず、メディアクエリの中にグルーピングされるので注意すること。

メディアクエリの中と外はしっかりと分けないといけない。
そうしないと予期しない動作になってしまう。　

31.複数継承と継承の連鎖
複数継承は、複数のセレクタを同時に1つのセレクタに継承すること。
１つのセレクタに2つ以上のextendを書く事ができる。　
そうする事でセレクタ内で共通する部分で分けて、差分を別でcssでは表示するようになる。　


継承の連鎖：extendで継承したセレクタをさらに継承元のセレクタとして継承する事。
継承元の継承元と共通するところはそれでグルーピングされて、継承元と共通するところはそこでグルーピング。残りの差分はそれ単体で表示される。　

継承の連鎖をさせすぎると大元の継承のセレクタのところに大量のセレクタがグルーピングされるのでむやみやたらに使用しない事。

オプショナルフラグについて、
extendで継承した時に、存在しないセレクタを指定した際はビルド時にエラーが発生する。
glupしていると保存した瞬間にエラーが出るが、
@extend　存在しないセレクタ名 optional;とするとエラーが出なくなる。
ただし、出力するextendの先がないのでcssには表示されない。

32.ミックスインと継承の違いの使い分け。
両方ともsassの目玉。
どちらも共通のスタイル部分を使用して使いまわせるものとしては似ている。
機能の性質が違うので特徴を理解する。

mixinは共通化するソースを設定して共有する。
mixinはインクルードしたところに表示される。
定義すればどこでも何度でも使用する事ができる。
定型分として出力する、必要なところにmixinに入力したものをコピペするというように使用する。

継承は引継ぎ拡張するという方法でソースを共通化する。
extendして継承したクラスは、カンマ区切りで出力される。
拡張した部分は別のスタイルで表示される。
extendはただ単にスタイルが共通するからと言って、継承をするのはやめるべき。
継承はグルーピングするという性質がある。
.button {
  padding: 10px;
  border: 1px solid #ccc;
}

.errorButton {
  @extend .button;
  background-color: #f00;
}

.buttonと.errorButtonはbutton というコンポーネントにグルーピングしているとい事。
そこに
.news_area {
  @extend .button;
}
とはするべきではない。
内容は同じかもしれないけれど、news_areaはbuttonではないから。
共通化したいのであれば、同じスタイルだとしても、
.area {
  padding: 10px;
  border: 1px solid #ccc;
}
というセレクタを作って、
.news_area {
  @extend .area;
}
とグルーピングしてあげないといけない。

継承というアイデアの元のオブジェクト指向でもそうだし、
継承するセレクタが遠くにあったり、別ファイルにあったりどこから継承されてきたのか。多重継承された場合、元のセレクタがどのように継承されてきたのかがわかりにくくなってしまうという実際の問題がある。

継承する場合は、ビルドされたcssを確認する方がいい。ネストが深くなると、グルーピングされたcssの数が多くなって、共通化した方がcssが多くなって共通化した意味がなくなるので注意する事。

出力されるcssの結果を想像しながら書くというのもsassの重要なコツ。　



　

