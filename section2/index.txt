11.ネストの基本。
ネストの書き方の基本を学ぶ。　
index.htmlを作成する。
そして、cssのフォルダにlecture11_css.cssのファイルを作ってどのようになるのかcss指定する。
main { width: 1000px;  margin: 0 auto;}
main section {  padding: 10px;}
main section h1 {  font-size: 1.4rem;}
main section p {  margin-bottom: 20px;}
main section p.note {  color: #f00;}
main section ul {  margin-bottom: 20px;}
main section ul li {  margin-left: 20px;}
のように設定できる
同じセレクタを何度も繰り返し、記述している事がわかる。
これをsassで書くと入れ子構造で書く事ができるので、繰り返す事がなくなる。　
sassファイルを新規作成する。
作成したらターミナルでgulpを実行する。
作業する前にはgulpで自動ビルドするように設定してから作業をする事。　

lecture11.scssに入力したものが、cssファイルに反映されて、先ほど書いたものを同じものができているのがわかる。　
sassで入れ子構造を利用して、記述が減っている事がわかる。
また、htmlと比較すると、htmlのツリータグとsassの入れ子構造が対応して、
構造が全体的に見やすくなっている。
html側の構造を変更して、mainにid="main"とidをつけたとすると、
scssの場合は一番上のmainタグに#をつけるだけで終了する。
これを保存してビルド結果を見るとmainで書いていたところが、
全て#mainに変更されている。　
sassだとI箇所の変更だけで済むので非常に便利。

sassを使ってnest構造で書くことで書く量が減って、また、構造が見やすくなる。
メンテナンス性も向上する。

13.隣接セレクタ、間接セレクタ、直下セレクタ
こまごセレクタ以外のセレクタをnestする の書き方はどうするのか。
まずは、cssを書いて見ていく。　

隣接セレクタは、ある要素に次に出てくる隣の要素に対して、スタイルを指定する。
要素同士を結合子＋繋げることで記述する。
ulタグのliタグのすぐ次に出てくるliタグを指定する方法。

間接セレクタは後ろに続く同階層のすべての要素のスタイルを適用する。
結合子~ で繋げる。
ulタグの中にliタグがたくさんあった場合、li~ li
2個目以降のliにスタイルを適用する場合に記入。
ul li ~ li {

}という風に記入する。


直下セレクタはある要素のすぐ直下にある要素にだけスタイルを適用。
結合子＞で繋げる。　
ul li > div{}のように使用する。
ulにあるliタグの直下にあるdivに適用する。　

これをsassのネストで書くとどうなるのか。

ul {
  li {
    + li {
      border-bottom: 1px solid #666;
    }
    ~ li {
      color: #f00;
    }
    > div {
      background: #ccc;
    }
  }
} 
とすることで先ほどcssに記入したものを同じように記入できる。

13.親セレクタの参照。
ネストで親セレクタの参照を使う方法を学ぶ。
1つの要素に複数のクラスのstyleを適用する場合を考える。　
btn と.btn.redまたは.btn.greenをつけるというパターンがあったとする。　
 btnクラスが共通しているがこれをネストして書く事ができる。
 親セレクトを参照するには& を使用して.red,.green等を指定してスタイルを書く
lecture13.scssのように記入することで同じように記述する事ができる。

親セレクタの参照はセレクタの前だけでなく、後ろにもつける事ができる。

body#top aside
bodyタグid topの中のasideをネストして表示するには、body#top &と記入する事ができる。
asideの記号を親セレクトの参照の&を使って書く。
そうする事で親セレクタの参照を使って記述された部分が
body#top aside {
  width: 300px;
}
のように記述されている。

さらに親セレクタは、擬似クラスや擬似要素の前にも書く事ができる。
a {
  text-decoration: none;

  &:hover {
      text-decoration: underline;
  }
}
と書くこともできる。

また、css設計でbemなどを　設定している場合親セレクタの参照を使って、ネストして書く事ができる。　
&を使用して記入する事でbemの命名規則でビルドされている事が確認できる。

  さらに親セレクタの参照は複数使用する事ができる。
& &__element とする事で階層を1つ深くする事ができる。
親セレクタの参照を&使って書くことで記述量を減らす事ができる。

14.プロパティのネスト
プロパティのネストについて確認する。 
borderなどショートハンドが存在するプロパティは、-のところで区切ってネストができる。
div.border-box { 
  border-top: 2px solid #000;
  border-bottom-width: 5px;
  border-bottom-style: dotted;
  border-bottom-color: #f00;
  border-radius: 5px;
}これを実際にscssで書いてみる。
ハイフンでネストできるのでそれでネストして書く。
lecture14.scssのようにかける。

 boxの上と左右にだけborderをつけたい場合を考える。
この場合は２パターンあって、上と左右を設定する方法と、
全てにborderをつけて、bottomだけあとで上書きで0にする事ができる。
後半の場合は上書きするものをネストして書く事で表現できる。
div.no-bottom-border2 {
  border: 1px solid #666 {
    bottom: 0;
  }
}
このような書き方をする。
期待した通りの出力結果になっている。

ネストしてかけるからと行って、ネストで書かないといけないという訳ではない。
プロパティを書くときに、ショートハンドで書いたほうがわかりやすいならそのままで大丈夫。

15.メディアクエリのネスト
画面サイズに応じてメディアクエリを利用する際に使用。
lecture15.scssのように記載する。
mediaクエリの中にさらにメディアクエリをネストする事ができる。
ネストしたmediaクエリはandで接続されて出力される。
@media screen and (max-width: 768px) and (max-width: 1024px) {
  main {
    width: 800px;
  }
}のように表示される。

さらにネストした子要素の中に、メディアクエリを書くこともできる。
 ネストした親子関係がmediaクエリの中に記載される。
mediaクエリの指定は画面幅の指定だけでなく、印刷用の指定プリントも使える。
#header を印刷の時非表示にしたい場合でもネストを使用して記入できる。
#header {
  height: 100px;
  border-bottom: 1px solid #999;

  @media print {
    display: none;
  }
}

sassのネストを使用して、同じファイルにmediaクエリを使用して、画面サイズやメディアの種類によってどのようなサイズが適用されるのかがわかりやすくなる。

16.@at-rootの使い方。
at-rootはネストして書いているセレクタを親セレクタやメディアクエリを除外して、root の位置に戻す事ができる。
 @at-rootを要素の前につけると親セレクタの.blockが除外されて,.element2がroot位置にいる事がわかる。　
   @at-root .element2 {
    width: 1000px;
  }

これがat-rootの機能。

at-rootは複数のルールセットにも使用する事ができる。
複数のルールセットに対して使用する場合は、
@at-root{}で{}の中に適用したいセレクタを入れると適用できる。
そうすると中に記載したセレクタがルート位置で出力される。

@at-rootはmediaクエリのネストの中でも使用する事ができる。
mediaクエリの中で行ったら、mediaクエリの中でしか表示されない。
mediaクエリの中からは出ない。　

mediaクエリからの出し方を学ぶ。
 @at-rootのオプションを使う。
 その1つがwithout
   @media screen and (max-width: 768px) {
    width: 100%;

      @at-root (without: media) .item {
      margin-bottom: 30px;
    }
  }
  とするとmediaの外にitemが出力される。

ここで注意なのが、出力がitemがrootで表示されているがこれは正しくない。　
nodeで使用している3.5.0には、バッグがあり、
本来は、.block .itemが正しい。.blockが残った状態で出力されるのが正しい状態。
.blockを外したい場合は、without: media ruleとruleをつけると取れる。
そして、.itemと表示される。

オプションのwithは指定したものだけが残り、それ以外が除外される。
with: mediaとした場合は、親クラスの.blockが削除されて、mediaは残った除外で表示される。

at-rootの機能は、ネストから外に書き出すもの。
内容がよくわからないがミックスインなどと組み合わせるのであとで見る。



